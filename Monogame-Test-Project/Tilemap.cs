using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using viewStuff;



namespace tilemap
{


    /*
    Tilemap in general

    The tilemap will be able to:
        
        Take a set of csv files generated by the 'Tiled' editor and
        read in the data to appropriately assign tile numbers to textures
        within the textures atlas.
     
    The renderer needs a way to interact with the tilemap class
         Potential solutions:

            1. (BAD) The renderer will simply interact with the ECS (!).
            create a tilemap manager which handles the pre-rendering 
            of the tilemap chunks depending on what is visible and what is not.
            The tilemap manager will handle sending information to the ECS for render.
            2. becuase individual textures cannot be sent to the entity manager (ECS),
            we will try and send them directly to the renderer

            

    Steps for rendering

    1. The static tilemap layers will be rendered to a static texture. This static texture
    will be rendered and no normal texture will be used when drawing it (just plain lighting).
    The other layers that require more lighting information like normals or material properties
    will be rendered after this, using the correct info and shader technique.

    */
    

    public class Tilemap
    {
        public int tileDim = 16;
        public int atlasNumTilesPerRow = 4;

        // tilemap layers loaded from file
        //public Dictionary<string, Dictionary<Vector2, int>> layers;
        public List<Dictionary<Vector2, int>> layers;
        
        public string textureAtlasID; // string name of texture stored in resourcemanager
        public string textureNormalAtlasID;

        // this enum provides a more accesible way to concretely define which indecies within the layer
        // list correspond to which layer in the map, functionally.
        enum LayerType
        {
            background,
            midground,
            midground_normal,
            collision,
            foreground,
            COUNT
        }

        public Tilemap(string textureAtlasID)
        {
            this.textureAtlasID = textureAtlasID;
            this.textureNormalAtlasID = "normal-atlas-dev";

            layers = new List<Dictionary<Vector2, int>>((int)LayerType.COUNT);
            //layers = new Dictionary<string, Dictionary<Vector2, int>>();

            // now we can simply add a layer (in order) for the tilemap which are rendered in order
            // and the layer indecies correspond to the enum present above (not yet implemented)
            //layers.Add("midground", LoadMap("../../../Content/MapData/test-map/test-map_test-mg.csv"));
            //layers.Add(LoadMap("../../../Content/MapData/test-map/test-map_test-mg.csv"));

            // this must be done in correct order (I will automate this later using the map name + _layername or something like that).
            layers.Add(LoadMap("../../../Content/MapData/map1/map1_background.csv"));
            layers.Add(LoadMap("../../../Content/MapData/map1/map1_midground.csv"));
            layers.Add(LoadMap("../../../Content/MapData/map1/map1_midground_normal.csv"));
            layers.Add(LoadMap("../../../Content/MapData/map1/map1_collision.csv"));
            layers.Add(LoadMap("../../../Content/MapData/map1/map1_foreground.csv"));


            //layers.Add(LoadMap("../../../Content/MapData/test-map/test-map_test-fg.csv"));

        }

        private Dictionary<Vector2, int> LoadMap(string filepath)
        {
            Dictionary<Vector2, int> result = new();
            StreamReader reader = new(filepath);
            int y = 0;
            string line;

            while((line = reader.ReadLine()) != null)
            {
                string[] items = line.Split(',');
                for (int x = 0; x < items.Length; x++)
                {
                    if (int.TryParse(items[x], out int value)) 
                    {
                        if (value > -1)
                        {
                            result[new Vector2(x, y)] = value;
                        }
                    }
                }
                y++;
            }
            return result;
        }


        //public bool isSolidAt(int x, int y)
        //{
        //    if (layers.ContainsKey("collisions"))
        //    {
        //        if (layers["collisions"][new Vector2(x, y)] > 0)
        //        {
        //            return true;
        //        }
        //    }
        //    return false;
        //}

        

        public bool isSolidAt(Vector2 pos)
        {
            if (layers[(int)LayerType.collision][pos] > 0)
            {
                return true;
            }
            //if (layers.ContainsKey("collisions"))
            //{
            //    if (layers["collisions"][pos] > 0)
            //    {
            //        return true;
            //    }
            //}
            return false;
        }
    }
}







// old draw function for tilemap that I want to keep around becuase the method was
// novel to me at the time I wrote it.

//public void Draw(SpriteBatch spriteBatch, Camera2D cam, 
//    RenderTarget2D target, GraphicsDevice graphicsDevice, Texture2D textureAtlas)
//{
//    //graphicsDevice.Clear(Color.CornflowerBlue);
//    graphicsDevice.SetRenderTarget(target);

//    spriteBatch.Begin(samplerState: SamplerState.PointClamp,
//        transformMatrix: cam.TransformMatrix);

//    int tileNumPixels = 16;

//    foreach (var item in mg)
//    {
//        Rectangle drect = new(
//            (int)item.Key.X * tileDim,
//            (int)item.Key.Y * tileDim,
//            tileDim,
//            tileDim);


//        int x = item.Value % atlasNumTilesPerRow;
//        int y = item.Value / atlasNumTilesPerRow;

//        Rectangle source = new(
//            x * tileNumPixels,
//            y * tileNumPixels,
//            tileNumPixels,
//            tileNumPixels);

//        spriteBatch.Draw(textureAtlas, drect, source, Color.White);
//    }

//    spriteBatch.End();
//}




// test comment from laptop

/**
 * Idea: don't  have a bunch of tilemap objects floating around in your game instead use
 *       a tilemap renderer which can take a tilemap object (which itself should load it's
 *       information from a JSON object), and properly render the information from it.
 *       This will decouple the tilemap structure from the actual rendering process
 */

/*
namespace tilemap
{
    public class TilemapManager
    {
        int[] tileTypes = new int[]
        {
            2, 8, 2, 8, 8, 8, 8, 8, 8, 8, 2, 8, 2, 2, 2, 8,
            2, 8, 2, 8, 8, 8, 8, 8, 8, 8, 2, 8, 2, 2, 2, 8,
            2, 8, 2, 8, 8, 8, 8, 8, 8, 8, 2, 8, 2, 2, 2, 8,
            2, 8, 2, 8, 8, 4, 4, 4, 4, 4, 2, 4, 2, 2, 2, 4,
            2, 4, 2, 4, 4, 4, 4, 4, 4, 4, 2, 4, 2, 2, 2, 4,
            2, 4, 2, 4, 4, 4, 4, 4, 4, 4, 2, 4, 2, 2, 2, 4,
            2, 4, 2, 4, 4, 4, 4, 4, 4, 4, 2, 4, 2, 2, 2, 4,
            2, 4, 2, 4, 4, 4, 4, 4, 4, 4, 2, 4, 2, 2, 2, 4,
            2, 4, 2, 4, 4, 4, 4, 4, 4, 4, 2, 4, 2, 2, 2, 4,
            2, 4, 2, 4, 4, 4, 4, 4, 4, 4, 2, 4, 2, 2, 2, 4,
            2, 4, 2, 4, 4, 4, 4, 4, 4, 4, 2, 4, 2, 2, 2, 4,
            2, 4, 2, 4, 4, 4, 4, 4, 4, 4, 2, 4, 2, 2, 2, 4,
            2, 4, 2, 4, 4, 4, 4, 4, 4, 4, 2, 4, 2, 2, 2, 4,
            2, 4, 2, 4, 4, 4, 4, 4, 4, 4, 2, 4, 2, 2, 2, 4,
            2, 4, 2, 4, 4, 4, 4, 4, 4, 4, 2, 4, 2, 2, 2, 4,
            2, 4, 2, 4, 4, 4, 4, 4, 4, 4, 2, 4, 2, 2, 2, 4,
        };

        public Texture2D spriteSheet;
        public RenderTarget2D target;
        public SpriteBatch spriteBatch;

        private GraphicsDeviceManager gMan;

        public Vector2 tileDim;
        public Vector2 mapTileDim;

        public TilemapManager(Vector2 tileDim, Vector2 mapTileDim, Texture2D spriteSheet, GraphicsDeviceManager gMan)
        {
            this.spriteSheet = spriteSheet;
            this.tileDim = tileDim;
            this.mapTileDim = mapTileDim;

            this.gMan = gMan;

            this.spriteBatch = new SpriteBatch(gMan.GraphicsDevice);

            this.target = new RenderTarget2D(
                gMan.GraphicsDevice, (int)(mapTileDim.X * tileDim.X), (int)(mapTileDim.Y * tileDim.Y));
        }

        public void Update(Vector2 playerPos)
        {
            
            gMan.GraphicsDevice.SetRenderTarget(target);
            gMan.GraphicsDevice.Clear(Color.White);

            this.spriteBatch.Begin(samplerState: SamplerState.PointClamp);
            
            for (int i = 0; i < tileTypes.Length; i++)
            {
                int x = i % (int)mapTileDim.X;
                int y = (i - x) / (int)mapTileDim.X;

                spriteBatch.Draw(
                    spriteSheet,
                    new Rectangle(
                        x * (int)tileDim.X, y * (int)tileDim.X, (int)tileDim.X, (int)tileDim.Y),
                    new Rectangle(
                        0, (int)(tileTypes[i] * tileDim.Y), (int)tileDim.X, (int)tileDim.Y),
                    Color.White);
            }

            this.spriteBatch.End();

        }

    }

}






*/

/*
public class TilemapRenderer
{
    public Tilemap tilemap;
    public RenderTarget2D mapCanvas;
    public SpriteBatch tileBatch;

    public TilemapRenderer(Tilemap tilemap, GraphicsDeviceManager graphicsDeviceManager)
    {
        this.tilemap = tilemap;

        tileBatch = new SpriteBatch(graphicsDeviceManager.GraphicsDevice);

        // init map render target
        mapCanvas = new RenderTarget2D(
            graphicsDeviceManager.GraphicsDevice,
            graphicsDeviceManager.PreferredBackBufferWidth, graphicsDeviceManager.PreferredBackBufferHeight,
            false,
            graphicsDeviceManager.GraphicsDevice.PresentationParameters.BackBufferFormat,
            DepthFormat.Depth24);
    }

    public void render(GraphicsDevice gDevice)
    {
        gDevice.SetRenderTarget(mapCanvas);
        gDevice.Clear(Color.White);

        tileBatch.Begin(SpriteSortMode.Immediate, BlendState.AlphaBlend, SamplerState.PointClamp);

        drawMapToTexture();

        tileBatch.End();

        gDevice.SetRenderTarget(null);
    }

    private void drawMapToTexture()
    {
        for (int row = 0; row < tilemap.mapHeight; row++)
        {
            for (int col = 0; col < tilemap.mapWidth; col++)
            {
                tileBatch.Draw(
                    tilemap.textureSheet,
                    new Rectangle(
                        col * tilemap.tileWidth,
                        row * tilemap.tileHeight,
                        tilemap.tileWidth,
                        tilemap.tileHeight),
                    new Rectangle(
                        0,
                        tilemap.tileTypes[row * tilemap.mapWidth + col] * tilemap.tileHeight,
                        tilemap.tileWidth,
                        tilemap.tileHeight),
                    Color.White);
            }
        }
    }




}
*/



// class logic:
/*
 * tilemap has its own spritebatch which it uses to draw to the rendertarget
 * 
 * when creating a new tilemap, a JSON file will be used to initialize all the values
 * that will be used for the tilemap such as the actual tilemap data, the dimensions
 * of the map, the size of each tile, etc.
*/

/**
 * Tilemap class handles storing information about tiles and drawing them to the screen
*/
/*
public class Tilemap
{
    public Texture2D textureSheet;
    public List<int> tileTypes;

    public int mapWidth;
    public int mapHeight;

    public int tileWidth;
    public int tileHeight;

    //public RenderTarget2D mapCanvas; // later use many dynamic map chunks to get most efficient rendering
    //private SpriteBatch tileSpriteBatch;

    // later change this to take JSON object information
    public Tilemap(int mapWidth, int mapHeight, int tileWidth, int tileHeight) 
    {
        this.mapWidth = mapWidth;
        this.mapHeight = mapHeight;
        this.tileWidth = tileWidth;
        this.tileHeight = tileHeight;

        tileTypes = new List<int>
        {
            3, 2, 4, 3, 3, 4, 4, 2, 4, 3, 2, 2, 4, 4, 2, 4,
            1, 3, 2, 2, 4, 3, 2, 1, 2, 2, 2, 2, 2, 1, 3, 4,
            2, 5, 5, 6, 4, 3, 4, 3, 2, 1, 1, 2, 3, 1, 2, 3,
            3, 2, 4, 3, 3, 4, 4, 2, 4, 3, 2, 2, 4, 4, 2, 4,
            1, 3, 2, 2, 4, 3, 2, 1, 2, 2, 2, 2, 2, 1, 3, 4,
            2, 5, 5, 6, 4, 3, 4, 3, 2, 1, 1, 2, 3, 1, 2, 3,
            3, 2, 4, 3, 3, 4, 4, 2, 4, 3, 2, 2, 4, 4, 2, 4,
            1, 3, 2, 2, 4, 3, 2, 1, 2, 2, 2, 2, 2, 1, 3, 4,
            2, 5, 5, 6, 4, 3, 4, 3, 2, 1, 1, 2, 3, 1, 2, 3,
            3, 2, 4, 3, 3, 4, 4, 2, 4, 3, 2, 2, 4, 4, 2, 4,
            1, 3, 2, 2, 4, 3, 2, 1, 2, 2, 2, 2, 2, 1, 3, 4,
            2, 5, 5, 6, 4, 3, 4, 3, 2, 1, 1, 2, 3, 1, 2, 3,
            3, 2, 4, 3, 3, 4, 4, 2, 4, 3, 2, 2, 4, 4, 2, 4,
            1, 3, 2, 2, 4, 3, 2, 1, 2, 2, 2, 2, 2, 1, 3, 4,
            2, 5, 5, 6, 4, 3, 4, 3, 2, 1, 1, 2, 3, 1, 2, 3,
            3, 2, 4, 3, 3, 4, 4, 2, 4, 3, 2, 2, 4, 4, 2, 4,
        };
    }




    // Draw to the texture once
    // then draw the texture to the screen using Game1's spritebatch

}
}
*/

// tyring to draw tilemap to it's own render texture
//if (!tilemap.isDrawn)
//{
//    GraphicsDevice.SetRenderTarget(tilemap.mapCanvas);
//    graphics.GraphicsDevice.DepthStencilState = new DepthStencilState() { DepthBufferEnable = true };
//    graphics.GraphicsDevice.Clear(Color.CadetBlue);

//    spriteBatch.Begin(SpriteSortMode.Immediate, BlendState.AlphaBlend,
//        SamplerState.PointClamp);

//    tilemap.Draw(spriteBatch);

//    spriteBatch.End();
//    GraphicsDevice.SetRenderTarget(null);
//    tilemap.isDrawn = true;
//}
